"""syphon.util.py

   Copyright Keithley Instruments, LLC.
   Licensed under MIT (https://github.com/tektronix/syphon/blob/master/LICENSE)

"""
import hashlib
import os
from _hashlib import HASH
from _io import _IOBase
from typing import Callable, Iterator, List, NamedTuple, Optional, Tuple

from . import errors


DEFAULT_HASH = hashlib.sha256()


SplitResult = NamedTuple(
    "SplitResult", [("hash", str), ("file", str), ("binary", bool)]
)


class HashEntry(object):
    def __init__(
        self, filepath: str, binary: bool = False, hash_obj: Optional[HASH] = None
    ):
        """An object whose string value represents a valid hash entry.

        Args:
            filepath: The target of the hash operation.
            binary: Whether the target file should be read in binary mode. Defaults
                to False.
            hash_obj: A hashlib-compatible object that handles hash implementation
                details. Defaults to SHA256.
        """
        super().__init__()
        self._hash_cache: str = ""
        self._hash_obj: HASH = hashlib.new(
            DEFAULT_HASH.name if hash_obj is None else hash_obj.name
        )
        # Used only when this object was generated by parsing a hash file.
        self._raw_entry: str = ""
        self.binary: bool = binary
        self.filepath: str = filepath

    def __str__(self) -> str:
        return " ".join(
            [self.hash, "{0}{1}".format("*" if self.binary else " ", self.filepath)]
        )

    @property
    def cached(self) -> bool:
        """Whether the hash has been cached.

        The cached hash is used to minimize the I/O overhead of multiple "hash"
        property accesses.
        """
        return self._hash_cache != ""

    @property
    def hash(self) -> str:
        """A hash calculated from the contents of the filepath.

        The initial property access caches the result of the hash operation. The cached
        value is used during subsequent accesses to minimize I/O overhead.

        Refer to the "cached" property to determine whether the cache will be used
        during the next access.
        """
        if len(self._hash_cache) > 0:
            return self._hash_cache

        new_hash = self._hash()
        self._hash_cache = new_hash
        return new_hash

    @property
    def hasher(self) -> HASH:
        """The object used to calculate the hash. Is an instance of _hashlib.HASH."""
        return self._hash_obj

    @hasher.setter
    def hasher(self, value: HASH):
        if not isinstance(value, HASH):
            raise TypeError("Expected {0}, received {1}".format(HASH, type(value)))
        self._hash_obj = hashlib.new(value.name)

    def _hash(self) -> str:
        """Calculate a hash from the contents of the filepath."""
        if self.binary:
            with open(self.filepath, "rb") as binary:
                self.hasher.update(binary.read())
        else:
            with open(self.filepath, "rt") as text:
                self.hasher.update(bytes(text.read(), text.encoding))

        return self.hasher.hexdigest()

    @staticmethod
    def _default_line_split(line: str) -> Optional[SplitResult]:
        import re

        captures: List[Tuple[str, str]] = re.findall(
            r"^([a-fA-F0-9]+)\s+(.*)$", line.strip()
        )
        try:
            match_tuple: Tuple[str, str] = captures.pop(0)
            filepath: str = match_tuple[1]
            is_binary: bool = filepath.startswith("*")
            return SplitResult(
                hash=match_tuple[0],
                file=filepath[1:] if is_binary else filepath,
                binary=is_binary,
            )
        except IndexError:
            pass

        return None

    @staticmethod
    def from_str(
        entry: str, line_split: Optional[Callable[[str], Optional[SplitResult]]] = None
    ) -> "HashEntry":
        """Create a HashEntry from a given entry string.

        Args:
            entry: The string parse into a HashEntry.
            line_split: A callable object that returns a SplitResult from a given line
                or None if the line is in an unexpected format. Returning None raises
                a MalformedLineError.

        Returns:
            HashEntry: An object wrapper for the matched hash entry.

        Raises:
            MalformedLineError: If there was trouble splitting the given entry.
        """
        if line_split is None:
            line_split = HashEntry._default_line_split

        split = line_split(entry)
        if split is None:
            raise errors.MalformedLineError(entry.strip())

        result = HashEntry(split.file, binary=split.binary)
        result._hash_cache = split.hash
        result._raw_entry = entry
        return result


class HashFile(object):
    def __init__(self, filepath: str, open_mode: str = "r"):
        """A wrapper around a hash file.

        Exposes a method to iterate through HashEntries.
        """
        super().__init__()
        self._file_obj: Optional[_IOBase] = None
        self._filename: str = os.path.basename(filepath)
        self._line_split: Optional[Callable[[str], Optional[SplitResult]]] = None
        self._open_mode: str = open_mode
        self.filepath: str = filepath

    def __enter__(self, *args, **kwargs) -> "HashFile":
        if self._file_obj is not None:
            return self
        self._file_obj = open(self.filepath, self._open_mode)
        return self

    def __exit__(self, *args, **kwargs) -> None:
        if self._file_obj is not None:
            self._file_obj.close()
            self._file_obj = None
        return None

    def entries(self) -> Iterator[HashEntry]:
        if self._file_obj is None:
            raise errors.FileNotOpenError(self.filepath)
        for line in self._file_obj:
            yield HashEntry.from_str(line, self._line_split)
